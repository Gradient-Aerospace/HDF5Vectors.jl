var documenterSearchIndex = {"docs":
[{"location":"api/#Public-Interface","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"api/#HDF5Vectors.HDF5Vectors","page":"Public Interface","title":"HDF5Vectors.HDF5Vectors","text":"This module implements an AbstractVector whose underlying data is stored in an HDF5 file.\n\nIt generally can store vectors of elements with fixed sizes, where that element is one of:\n\nHDF5-compatible numeric type (signed/unsigned ints and floats)\nEnum\nSVector, SMatrix, and SArray of numeric types\nTuple of numeric types\nbits-type consisting of any types on this list\ngeneral composite type consisting of any types on this list\nVector, Matrix, and Array of any types on this list, as long as their dimensions are always the same\nString\n\nFuther, it can serialize types to bytes or strings and store those in the HDF5 file. This allows it to store:\n\nAny type that serializes\nVector, Matrix, and Array that are different lengths from element to element (via serialization)\n\nIt fulfills the general AbstractVector interface. Note, however, that iterating directly is slow; for far better speed, iterate on iterable(arr).\n\n\n\n\n\n","category":"module"},{"location":"api/#HDF5Vectors.AbstractHDF5Vector","page":"Public Interface","title":"HDF5Vectors.AbstractHDF5Vector","text":"An abstract type intended as the parent for all type of HDF5 vectors. Subtypes should have a corresponding storage style and implement create_hdf5_vector, and at least these parts of the AbstractArray interface: length, setindex!, push!, getindex, and  collect.\n\n\n\n\n\n","category":"type"},{"location":"api/#HDF5Vectors.AbstractHDF5VectorStorageStyle","page":"Public Interface","title":"HDF5Vectors.AbstractHDF5VectorStorageStyle","text":"An abstract type intended as a parent for all HDF5 vector storage styles.\n\n\n\n\n\n","category":"type"},{"location":"api/#HDF5Vectors.CompositeStorageStyle","page":"Public Interface","title":"HDF5Vectors.CompositeStorageStyle","text":"Used to store composite structured information, like:\n\nGeneral tuple of types on this list\nGeneral named tuple of types on this list\nGeneral struct of types on this list\n\n\n\n\n\n","category":"type"},{"location":"api/#HDF5Vectors.ElementalStorageStyle","page":"Public Interface","title":"HDF5Vectors.ElementalStorageStyle","text":"Used to store \"elemental\" types â€“ types that HDF5 can natively understand, including:\n\nInt8, Int16, Int32, and Int64 (and unsigned forms)\nFloat32 and Float64\nEnum\nChar\nBits-type structs\nString\n\n\n\n\n\n","category":"type"},{"location":"api/#HDF5Vectors.construct","page":"Public Interface","title":"HDF5Vectors.construct","text":"construct(type::Type, el)\n\nTODO: Update. Given the el \"element\", as stored in the HDF5 file, the constructs the given type. What the element is depends on the storage style associated with the type.\n\n\n\n\n\n","category":"function"},{"location":"api/#HDF5Vectors.create_hdf5_vector-Tuple{Any, Any, Any}","page":"Public Interface","title":"HDF5Vectors.create_hdf5_vector","text":"create_hdf5_vector(group, name, el_type; kwargs...)\n\nCreates the appropriate HDF5 vector type for the given element type, storing the vector in the given HDF5 groupin a new group/dataset,name`.\n\nOptional keyword arguments:\n\ndims: Tuple of the dimensions to use for a Vector, Matrix, or Array\nchunk_length: Length of chunk to use (default 1000)\nportable: True to maximize how \"portable\" the storage is (default true)\n\n\n\n\n\n","category":"method"},{"location":"api/#HDF5Vectors.create_hdf5_vector-Tuple{HDF5Vectors.AbstractHDF5VectorStorageStyle, Any, Any, Any}","page":"Public Interface","title":"HDF5Vectors.create_hdf5_vector","text":"create_hdf5_vector(style, group, name, el_type; kwargs...)\n\nCreates the appropriate HDF5 vector type for the given storage style and element type, storing the vector in the given HDF5 groupin a new group/dataset,name`.\n\nOptional keyword arguments:\n\ndims: Tuple of the dimensions to use for a Vector, Matrix, or Array\nchunk_length: Length of chunk to use (default 1000)\nportable: True to maximize how \"portable\" the storage is (default true)\n\n\n\n\n\n","category":"method"},{"location":"api/#HDF5Vectors.deconstruct","page":"Public Interface","title":"HDF5Vectors.deconstruct","text":"deconstruct(type::Type, el)\n\nTODO: Update.\n\nDecomposes the given el element into the datatype used for storage in the HDF5 file. This depends on the storage style associated with the type of the element.\n\n\n\n\n\n","category":"function"},{"location":"api/#HDF5Vectors.iterable-Tuple{AbstractHDF5Vector}","page":"Public Interface","title":"HDF5Vectors.iterable","text":"iterable(arr::AbstractHDF5Vector)\n\nReturns an iterable type corresponding to the given HDF5 vector. This is generally much faster than iterating on the vector directly. That is, instead of [f(el) for el in arr], it is much faster to use [f(el) for el in iterable(arr)]. \n\n\n\n\n\n","category":"method"},{"location":"api/#HDF5Vectors.load_hdf5_vector-Tuple{Any, Any}","page":"Public Interface","title":"HDF5Vectors.load_hdf5_vector","text":"TODO\n\n\n\n\n\n","category":"method"},{"location":"api/#HDF5Vectors.load_hdf5_vector-Tuple{Any}","page":"Public Interface","title":"HDF5Vectors.load_hdf5_vector","text":"TODO\n\n\n\n\n\n","category":"method"},{"location":"api/#HDF5Vectors.storage_style-Tuple{Type}","page":"Public Interface","title":"HDF5Vectors.storage_style","text":"storage_style(el_type::Type; kwargs...)\n\nReturns the storage style intended for this type. Available styles include:\n\nElementalStorageStyle for scalars or non-portable bits-type structs\nArrayStorageStyle for arrays of known, consistent dimensions holding elemental types\nCompositeStorageStyle for general structs\nByteArrayStorageStyle for arrays of inconsistent dimensions\nJSONStorageStyle for serializing types to JSON strings\n\nThe default storage style for scalars and \"non-portable\" bits-type structs (more below) is ElementalStorageStyle. For vectors with known dimensions, ArrayStorageStyle is the default. For other structs (either non-bits-types or \"portable\"), the default is CompositeStorageStyle. For all other types, ByteArrayStorageStyle is the default storage style.\n\nArray storage results in HDF5 files where the dataset has the dimensions of each element, plus one added dimension. For instance, if each element to be stored is an m-by-n array, then the HDF5 file will contain an m-by-n-by-p array, where element k is [:, :, k].\n\nStructs can be stored in a \"portable\" way. For the a struct defined as:\n\nstruct MyType\n    a::Int64\n    b::Float64\nend\n\nthe resulting HDF5 file would look like so:\n\n/my_group/my_vector/arrays/a # a 1D array of Int64\n/my_group/my_vector/arrays/b # a 1D array of Float64\n\nThis format is called \"portable\" because it is easy to interpret this dataset outside of Julia.\n\n\"Portability\" is controlled by the portable keyword argument. When this is false, the above struct would be stored as:\n\n/my_group/my_vector # a 1D array of custom type inferred from MyType\n\nThis uses the HDF5 type system via the HDF5.jl package to encode the type. The underlying data can still be interpreted outside of Julia, but it requires substantially more code to interpret the type information in a useful way. If you are only interested in loading the HDF5 in Julia, use portable = false, and the resulting storage will be faster. (Note that non-bits types cannot use the HDF5 type system and hence will always use the portable form.)\n\nWhen the elements to be stored are themselves vectors, matrices, or arrays of known dimension, the user should provide those dimensions via the dims keyword argument. Otherwise, since the dimensions of an array are not known from its type, and it's not known if the user intends for dimensions to be consistent over time or not, \n\nKeyword arguments:\n\nportable: When true (the default), composite types like structs will be stored in a  slower but more portable way. (For other types, this argument is ignored.)\ndims: Sets the dimensions of Array types (otherwise, ignored), such as (3, 4) when each element is a 3-by-4 matrix.\n\nUsers can add a storage_style method for their custom types to allow them to express how their types out to be stored. E.g., if a type should always be serialized, then this would instruct Julia to use serialization to a byte array for the give type:\n\nHDF5Vectors.storage_style(::Type{MyType}; kwargs...) = HDF5Vectors.ByteArrayStorageStyle()\n\n\n\n\n\n","category":"method"},{"location":"custom_element_types/#Custom-Element-Types","page":"Custom Element Types","title":"Custom Element Types","text":"Most types can be stored reasonably well as HDF5 vectors without having to specifying anything about how that should happen. However, sometimes it's desireable to have more control. In that case, it's possible to specify how a custom type should be stored in the HDF5 file, using one of the existing storage styles. The following methods should be implemented for the type:\n\nstorage_style\nconstruct\ndeconstruct\n\nHere's a complete example of a custom type for recording student grades, where the grade itself is stored as a string, but we really that's just going to be A, B, C, D, or F. Here is the native type:\n\nstruct Grade\n    label::String\nend\n\nHere's what's necessary to store this as the \"elemental\" style, where the label is stored as a char (UInt8).\n\nusing HDF5Vectors\nimport HDF5Vectors: storage_style, construct, deconstruct\n\n# Tell it we want this stored using the \"elemental\" style, with Chars.\nstorage_style(::Type{Grade}; kwargs...) = HDF5Vectors.ElementalStorageStyle(UInt8)\n\n# To store a Grade, pull the first (and only) char from the label.\ndeconstruct(::Type{UInt8}, el) = UInt8(only(el.label))\n\n# To rebuild a Grade from what was stored, make a string from the char.\nconstruct(::Type{Grade}, el) = Grade(string(Char(el)))\n\nNow let's give that a try:\n\nusing HDF5\nh5open(\"custom_element_type.h5\", \"w\") do fid\n\n    # Create the vector.\n    arr = create_hdf5_vector(fid, \"grades\", Grade)\n\n    # Add some grades.\n    push!(arr, Grade(\"A\"))\n    push!(arr, Grade(\"B\"))\n    push!(arr, Grade(\"C\"))\n    push!(arr, Grade(\"D\"))\n    push!(arr, Grade(\"F\"))\n\n    # Show how that's stored in the file itself:\n    @show read(fid[\"grades\"])\n\n    # Show that in fact Grades are rebuilt from that data.\n    @show collect(arr)\n\nend\n\nThe resulting output is what we'd expect:\n\nread(fid[\"grades\"]) = UInt8[0x41, 0x42, 0x43, 0x44, 0x46]\ncollect(arr) = Grade[Grade(\"A\"), Grade(\"B\"), Grade(\"C\"), Grade(\"D\"), Grade(\"F\")]","category":"section"},{"location":"custom_vector_types/#Custom-HDF5-Vector-Types","page":"Custom HDF5 Vector Types","title":"Custom HDF5 Vector Types","text":"To create a new type of HDF5 vector, you will need to define a new storage style type (<:AbstractHDF5VectorStorageStyle), create your type (<:AbstractHDF5Vector), and then implement following HDF5Vectors functions:\n\ncreate_hdf5_vector(style::AbstractHDF5VectorStorageStyle, group, name, el_type; kwargs...)\n\nas well as the AbstractArray interface:\n\nBase.length(v)\nBase.setindex!(v, el, k)\nBase.push!(v, el)\nBase.getindex(v, k)\nBase.collect(v)\n\nThese have definitions for AbstractHDF5Vector and likely don't need custom implementations:\n\niterable\nBase.eltype(v)\nBase.size(v)\nBase.similar(v, ...)\nBase.broadcastable(v)\nBase.map(f, v)\nBase.mapreduce(f, op, v; kwargs...)\nBase.iterate(v) and Base.iterate(v, state)\n\nFor an example of implementing a new type of storage, see the source for HDF5VectorOfCompositeTypes. It is fairly short, despite that it is used for the storage of all composite types in this package.","category":"section"},{"location":"#HDF5Vectors","page":"Home","title":"HDF5Vectors","text":"This package provides a mechanism for storing vectors in HDF5 files rather than in RAM. Those vectors adhere to the AbstractVector syntax and can grow over time via push!. This can be particularly useful for long-running calculations, where the data that gets produced is simply too much to fit in RAM.","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"Here is a simple example. We use HDF5 to open a file, and we use HDF5Vectors to create a vector in that HDF5 file.\n\nimport HDF5\nusing HDF5Vectors\n\n# Create an HDF5 file to store stuff in.\nfid = HDF5.h5open(\"storage.h5\", \"w\")\n\n# Create an array for Float64s called \"x\" in that file.\narr = create_hdf5_vector(fid[\"/\"], \"x\", Float64)\n\n# Push some elments into the array.\nfor el in 1. : 100.\n    push!(arr, el)\nend\n\n# We can now do whatever we want with that array, such as\n@show arr[end]\n@show sum(arr)\n@show collect(arr)\n\n# Always close out the file when you're done.\nclose(fid)\n\nWe can also create a new HDF5 vector based on existing storage in an HDF5 file.\n\nfid = HDF5.h5open(\"storage.h5\")\narr = load_hdf5_vector(fid[\"/x\"], Float64)\n\nThis example could be repeated for many different types in Julia.","category":"section"},{"location":"#Supported-Types","page":"Home","title":"Supported Types","text":"This works for storing most types, including:\n\nElemental types:\n\nInt8, Int16, Int32, and Int64 (and unsigned forms)\nFloat32 and Float64\nEnum\nChar\nBits-type structs\nString\n\nArray-like types:\n\nSVector, SMatrix, and SArray of elemental type\nVector, Matrix, and Array of element type, where dimensions are constant from element to element\nNTuple of elemental type\n\nComposite types:\n\nGeneral tuple of types on this list\nGeneral named tuple of types on this list\nGeneral struct of types on this list\n\nSerialized types:\n\nVector, Matrix, and Array of non-elemental type or where the dimensions are not known in advance\nAny type that serializes to a JSON string","category":"section"},{"location":"#Iteration","page":"Home","title":"Iteration","text":"When iterating over an HDF5Vector, it's far faster to call iterable on the vector and then iterate on what that returns. For example:\n\narr = create_hdf5_vector(...)\n...\n[el.x^2 + el.y^2 for el in iterable(arr)]\n\nThe reason this is faster is that iterable creates a structure intended to take advantage of the way HDF5.jl will access the data.","category":"section"},{"location":"#Loading-an-Existing-Array","page":"Home","title":"Loading an Existing Array","text":"Loading an HDF5 vector stored in an HDF5 file is straightforward:\n\nfid = HDF5.h5open(\"storage.h5\")\narr = load_hdf5_vector(fid[\"/x\"])\n\nWhere the type to load is known in advance, this works as well:\n\nfid = HDF5.h5open(\"storage.h5\")\narr = load_hdf5_vector(fid[\"/x\"], Float64)","category":"section"},{"location":"#How-Data-Is-Stored","page":"Home","title":"How Data Is Stored","text":"","category":"section"},{"location":"#Elemental-Types","page":"Home","title":"Elemental Types","text":"These will simply be n-element arrays in the HDF5 file.","category":"section"},{"location":"#Array-Like-Types","page":"Home","title":"Array-Like Types","text":"When the elements to be stored each have dimensions like (M, N, ...), the HDF5 file will have an array of the appropriate type whose dimensions are (M, N, ..., Z), where Z is the number of elements being stored. This is easy to interpret outside of Julia while also allowing fast access and efficient storage.\n\nWhen the elements to store are Vector, Matrix, or Array (or any AbstractArray whose dimensions are not known from the type), the dims = (M, N, ...) argument must be provided to create_hdf_vector. Otherwise, Arrays cannot be generally stored with array-like storage and will instead be serialized to byte arrays, which if far slower and unintepretable outside of Julia.","category":"section"},{"location":"#Composite-Types","page":"Home","title":"Composite Types","text":"There are two ways to store a composite type: \"portable\" and \"non-portable\".\n\n\"Portable\" storage means that an HDF5 group is created for each field of the struct, and inside of each is a group/dataset.\n\nTo see how structs can be stored portably, imagine we want a vector of 100 MyType elements, where:\n\nstruct MySubType\n    c::Int64                # Elemental\n    d::NTuple{2, Float64}   # Array-like\nend\nstruct MyType\n    a::Float64              # Elemental\n    b::MySubType            # Composite\nend\n\nIf the HDF5 vector were created in the \"/mygroup\" group with the name \"mytype\", those would be stored portably like so:\n\n/my_group/my_type/                  # Group\n/my_group/my_type/arrays/a          # Array of 100 Float64\n/my_group/my_type/arrays/b          # Group\n/my_group/my_type/arrays/b/arrays/c # Array of 100 Int64\n/my_group/my_type/arrays/b/arrays/d # Array of 2-by-100 Float64\n\nFor bits-type structs, a user can specify that they want \"non-portable\" storage. This means that HDF5.jl package can define a custom HDF5 type to store the struct, and the resulting HDF5 file will look like this:\n\n/my_group/my_type/ # An array of the HDF5 custom type\n\nThis is much faster and more efficient, but accessing it outside of Julia will require substantially more code to work with the HDF5 test definition system.","category":"section"},{"location":"#Serialized-Types","page":"Home","title":"Serialized Types","text":"When a type is too flexible/odd for the above, it can be stored via serialization. This is far slower, but it works for almost everything. There are two types of serialization currently provided.\n\nThe ByteArrayStorageStyle uses Julia's Serialization package to serialize a given type to a byte array. The resulting HDF5 dataset will be uninterpretable outside of Julia.\n\nThe JSONStorageStyle uses the JSON3 package to serialize a given type to a JSON string. The resulting HDF5 dataset will be an array of JSON strings. See the example below. In order to use the JSONStorageStyle, your project will have to import JSON3.","category":"section"},{"location":"#Specifying-a-Storage-Type","page":"Home","title":"Specifying a Storage Type","text":"Users can specify what \"style\" of storage should be used for a given type. For instance, suppose we had the following type:\n\n@enum ServerStatus unknown up down\nstruct SomeServerDetails\n    hostname::String\n    status::ServerStatus\nend\n\nWhen that's stored in the HDF5 file, let's make it serialize to JSON. To do this, we can apply the following trait:\n\nimport HDF5Vectors: storage_style, JSONStorageStyle\nstorage_style(::Type{SomeServerDetails}; kwargs...) = JSONStorageStyle()\n\nThat's it. Now, when we create an array for this type, each element will be serialized to JSON. The resulting HDF5 file will have an array of strings that can be loaded in any other environment. To complete the example:\n\nimport HDF5\nusing HDF5Vectors\nHDF5.h5open(\"server_details.h5\", \"w\") do fid\n    details = create_hdf5_vector(fid, \"details\", SomeServerDetails)\n    push!(details, SomeServerDetails(\"localhost\", up))\n    push!(details, SomeServerDetails(\"old_pc\", down))\n    push!(details, SomeServerDetails(\"phone\", unknown))\n    @show collect(details)\nend","category":"section"}]
}
