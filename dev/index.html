<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · My Documentation for HDF5Vectors</title><meta name="title" content="Home · My Documentation for HDF5Vectors"/><meta property="og:title" content="Home · My Documentation for HDF5Vectors"/><meta property="twitter:title" content="Home · My Documentation for HDF5Vectors"/><meta name="description" content="Documentation for My Documentation for HDF5Vectors."/><meta property="og:description" content="Documentation for My Documentation for HDF5Vectors."/><meta property="twitter:description" content="Documentation for My Documentation for HDF5Vectors."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>My Documentation for HDF5Vectors</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Supported-Types"><span>Supported Types</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Loading-an-Existing-Array"><span>Loading an Existing Array</span></a></li><li><a class="tocitem" href="#How-Data-Is-Stored"><span>How Data Is Stored</span></a></li><li><a class="tocitem" href="#Specifying-a-Storage-Type"><span>Specifying a Storage Type</span></a></li></ul></li><li><a class="tocitem" href="api/">Public Interface</a></li><li><a class="tocitem" href="custom_element_types/">Custom Element Types</a></li><li><a class="tocitem" href="custom_vector_types/">Custom HDF5 Vector Types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="HDF5Vectors"><a class="docs-heading-anchor" href="#HDF5Vectors">HDF5Vectors</a><a id="HDF5Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#HDF5Vectors" title="Permalink"></a></h1><p>This package provides a mechanism for storing vectors in HDF5 files rather than in RAM. Those vectors adhere to the AbstractVector syntax and can grow over time via <code>push!</code>. This can be particularly useful for long-running calculations, where the data that gets produced is simply too much to fit in RAM.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here is a simple example. We use HDF5 to open a file, and we use HDF5Vectors to create a vector in that HDF5 file.</p><pre><code class="nohighlight hljs">import HDF5
using HDF5Vectors

# Create an HDF5 file to store stuff in.
fid = HDF5.h5open(&quot;storage.h5&quot;, &quot;w&quot;)

# Create an array for Float64s called &quot;x&quot; in that file.
arr = create_hdf5_vector(fid[&quot;/&quot;], &quot;x&quot;, Float64)

# Push some elments into the array.
for el in 1. : 100.
    push!(arr, el)
end

# We can now do whatever we want with that array, such as
@show arr[end]
@show sum(arr)
@show collect(arr)

# Always close out the file when you&#39;re done.
close(fid)</code></pre><p>We can also create a new HDF5 vector based on existing storage in an HDF5 file.</p><pre><code class="nohighlight hljs">fid = HDF5.h5open(&quot;storage.h5&quot;)
arr = load_hdf5_vector(fid[&quot;/x&quot;], Float64)</code></pre><p>This example could be repeated for many different types in Julia.</p><h2 id="Supported-Types"><a class="docs-heading-anchor" href="#Supported-Types">Supported Types</a><a id="Supported-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Types" title="Permalink"></a></h2><p>This works for storing most types, including:</p><p>Elemental types:</p><ul><li>Int8, Int16, Int32, and Int64 (and unsigned forms)</li><li>Float32 and Float64</li><li>Enum</li><li>Char</li><li>Bits-type structs</li><li>String</li></ul><p>Array-like types:</p><ul><li>SVector, SMatrix, and SArray of elemental type</li><li>Vector, Matrix, and Array of element type, where dimensions are constant from element to element</li><li>NTuple of elemental type</li></ul><p>Composite types:</p><ul><li>General tuple of types on this list</li><li>General named tuple of types on this list</li><li>General struct of types on this list</li></ul><p>Serialized types:</p><ul><li>Vector, Matrix, and Array of non-elemental type or where the dimensions are not known in advance</li><li>Any type that serializes to a JSON string</li></ul><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><p>When iterating over an HDF5Vector, it&#39;s far faster to call <a href="api/#HDF5Vectors.iterable-Tuple{AbstractHDF5Vector}"><code>iterable</code></a> on the vector and then iterate on what that returns. For example:</p><pre><code class="nohighlight hljs">arr = create_hdf5_vector(...)
...
[el.x^2 + el.y^2 for el in iterable(arr)]</code></pre><p>The reason this is faster is that <a href="api/#HDF5Vectors.iterable-Tuple{AbstractHDF5Vector}"><code>iterable</code></a> creates a structure intended to take advantage of the way HDF5.jl will access the data.</p><h2 id="Loading-an-Existing-Array"><a class="docs-heading-anchor" href="#Loading-an-Existing-Array">Loading an Existing Array</a><a id="Loading-an-Existing-Array-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-an-Existing-Array" title="Permalink"></a></h2><p>Loading an HDF5 vector stored in an HDF5 file is straightforward:</p><pre><code class="nohighlight hljs">fid = HDF5.h5open(&quot;storage.h5&quot;)
arr = load_hdf5_vector(fid[&quot;/x&quot;])</code></pre><p>Where the type to load is known in advance, this works as well:</p><pre><code class="nohighlight hljs">fid = HDF5.h5open(&quot;storage.h5&quot;)
arr = load_hdf5_vector(fid[&quot;/x&quot;], Float64)</code></pre><h2 id="How-Data-Is-Stored"><a class="docs-heading-anchor" href="#How-Data-Is-Stored">How Data Is Stored</a><a id="How-Data-Is-Stored-1"></a><a class="docs-heading-anchor-permalink" href="#How-Data-Is-Stored" title="Permalink"></a></h2><h3 id="Elemental-Types"><a class="docs-heading-anchor" href="#Elemental-Types">Elemental Types</a><a id="Elemental-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Elemental-Types" title="Permalink"></a></h3><p>These will simply be n-element arrays in the HDF5 file.</p><h3 id="Array-Like-Types"><a class="docs-heading-anchor" href="#Array-Like-Types">Array-Like Types</a><a id="Array-Like-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Like-Types" title="Permalink"></a></h3><p>When the elements to be stored each have dimensions like (M, N, ...), the HDF5 file will have an array of the appropriate type whose dimensions are (M, N, ..., Z), where Z is the number of elements being stored. This is easy to interpret outside of Julia while also allowing fast access and efficient storage.</p><p>When the elements to store are Vector, Matrix, or Array (or any AbstractArray whose dimensions are not known from the type), the <code>dims = (M, N, ...)</code> argument must be provided to <code>create_hdf_vector</code>. Otherwise, Arrays cannot be generally stored with array-like storage and will instead be serialized to byte arrays, which if far slower and unintepretable outside of Julia.</p><h3 id="Composite-Types"><a class="docs-heading-anchor" href="#Composite-Types">Composite Types</a><a id="Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Types" title="Permalink"></a></h3><p>There are two ways to store a composite type: &quot;portable&quot; and &quot;non-portable&quot;.</p><p>&quot;Portable&quot; storage means that an HDF5 group is created for each field of the struct, and inside of each is a group/dataset.</p><p>To see how structs can be stored portably, imagine we want a vector of 100 <code>MyType</code> elements, where:</p><pre><code class="nohighlight hljs">struct MySubType
    c::Int64                # Elemental
    d::NTuple{2, Float64}   # Array-like
end
struct MyType
    a::Float64              # Elemental
    b::MySubType            # Composite
end</code></pre><p>If the HDF5 vector were created in the &quot;/my<em>group&quot; group with the name &quot;my</em>type&quot;, those would be stored portably like so:</p><pre><code class="nohighlight hljs">/my_group/my_type/                  # Group
/my_group/my_type/arrays/a          # Array of 100 Float64
/my_group/my_type/arrays/b          # Group
/my_group/my_type/arrays/b/arrays/c # Array of 100 Int64
/my_group/my_type/arrays/b/arrays/d # Array of 2-by-100 Float64</code></pre><p>For bits-type structs, a user can specify that they want &quot;non-portable&quot; storage. This means that HDF5.jl package can define a custom HDF5 type to store the struct, and the resulting HDF5 file will look like this:</p><pre><code class="nohighlight hljs">/my_group/my_type/ # An array of the HDF5 custom type</code></pre><p>This is much faster and more efficient, but accessing it outside of Julia will require substantially more code to work with the HDF5 test definition system.</p><h3 id="Serialized-Types"><a class="docs-heading-anchor" href="#Serialized-Types">Serialized Types</a><a id="Serialized-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Serialized-Types" title="Permalink"></a></h3><p>When a type is too flexible/odd for the above, it can be stored via serialization. This is far slower, but it works for almost everything. There are two types of serialization currently provided.</p><p>The <code>ByteArrayStorageStyle</code> uses Julia&#39;s Serialization package to serialize a given type to a byte array. The resulting HDF5 dataset will be uninterpretable outside of Julia.</p><p>The <code>JSONStorageStyle</code> uses the JSON3 package to serialize a given type to a JSON string. The resulting HDF5 dataset will be an array of JSON strings. See the example below. In order to use the <code>JSONStorageStyle</code>, your project will have to import JSON3.</p><h2 id="Specifying-a-Storage-Type"><a class="docs-heading-anchor" href="#Specifying-a-Storage-Type">Specifying a Storage Type</a><a id="Specifying-a-Storage-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-a-Storage-Type" title="Permalink"></a></h2><p>Users can specify what &quot;style&quot; of storage should be used for a given type. For instance, suppose we had the following type:</p><pre><code class="nohighlight hljs">@enum ServerStatus unknown up down
struct SomeServerDetails
    hostname::String
    status::ServerStatus
end</code></pre><p>When that&#39;s stored in the HDF5 file, let&#39;s make it serialize to JSON. To do this, we can apply the following trait:</p><pre><code class="nohighlight hljs">import HDF5Vectors: storage_style, JSONStorageStyle
storage_style(::Type{SomeServerDetails}; kwargs...) = JSONStorageStyle()</code></pre><p>That&#39;s it. Now, when we create an array for this type, each element will be serialized to JSON. The resulting HDF5 file will have an array of strings that can be loaded in any other environment. To complete the example:</p><pre><code class="nohighlight hljs">import HDF5
using HDF5Vectors
HDF5.h5open(&quot;server_details.h5&quot;, &quot;w&quot;) do fid
    details = create_hdf5_vector(fid, &quot;details&quot;, SomeServerDetails)
    push!(details, SomeServerDetails(&quot;localhost&quot;, up))
    push!(details, SomeServerDetails(&quot;old_pc&quot;, down))
    push!(details, SomeServerDetails(&quot;phone&quot;, unknown))
    @show collect(details)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">Public Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 3 December 2025 23:21">Wednesday 3 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
